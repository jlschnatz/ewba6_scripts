---
title: "EW-BA6"
subtitle: "Datenaufbereitung"
author:
  - name: "Erik Grützner"
    affiliation: "Institut für Psychologie, Abteilung für Differentielle Psychologie und Psychologische Diagnostik"
    email: gruetzner@psych.uni-frankfurt.de
    corresponding: false
  - name: "Luca Schnatz"
    affiliation: "Institut für Psychologie, Abteilung für Psychologische Methoden mit Interdisziplinärer Ausrichtung"
    email: schnatz@psych.uni-frankfurt.de
    corresponding: true
date: today   
---


# Einleitung

In diesem Skript geht es um die Vorbereitungen für die Analysen, die ihr im Rahmen eurer Hausarbeit rechnen sollt. Das heißt, wir bereiten die Daten so auf, dass sie mithilfe des 2. Skripts ausgewertet werden können. Dies machen wir anhand eines Beispieldatensatzes, der eurem ähnelt und auch die gleichen Probleme und Fallstricke beinhaltet, sodass ihr im besten Fall die Skripte kopieren könnt und nur noch an eure Studien anpassen müsst.

# Daten in R laden

Als erstes müssen die notwendigen Pakete geladen werden.

Im zweiten Schritt müsst ihr die erhobenen Daten aus SosciSurvey in R laden, um dort mit den Daten rechnen und arbeiten zu können. Wenn man Dateien von SosciSurvey herunterlädt, liegen sie üblicherweise als `.csv` oder als `.excel` vor, hier als `.csv`.

Ladet den Datensatz wie im entsprechenden Video vorgestellt von SosciSurvey herunter und stellt euer Working Directory richtig ein (`setwd()`). Dies muss der Ordner sein, indem der Datensatz liegt (verschiebt ihn hierfür manuell aus dem Downloadordner). Danach kann der Datensatz folgendermaßen eingelesen werden `read_csv()`.

```{r}
#| echo: false

library(dplyr)
library(naniar)
library(psych)
library(readr)
library(sjmisc)
library(kableExtra)

data_roh <- read.csv("data/raw/data_ewba6_raw_v2.csv") # Datensatz in R laden

```


```{r}
#| eval: false
#| echo: true
## Pakete laden:
install.packages("dplyr")
library(dplyr)

install.packages("naniar")
library(naniar)

install.packages("psych")
library(psych)

install.packages("readr")
library(readr)

install.packages("sjmisc")
library(sjmisc)

## Abfrage und Einstellen des Working Directory:
getwd() # Abfrage des Working Directory
setwd("C:path/to/directory") # Hier euren Ordner einstellen

## Datensatz einladen
data_roh <- read.csv("name-des-datensatzes.csv") # Datensatz in R laden
```

# Überblick über die Daten erhalten

Als erstes betrachten wir, welche Variablen alle existieren. Hierfür nutzen wir den `colnames()`-Befehl, der uns die Spaltennamen anzeigt. Im nächsten Schritt speichern wir einen 2. Datensatz, in dem die Variablen, die uns nicht interessieren (z.B. die IDs in SosciSurvey, die benötige Zeit, etc.) herauslöschen. Wir wählen hier die Proband:innen-Nummer, die demografischen Variablen (fangen alle mit "EI" an), die Items unseres Fragebogens (fangen alle mit "K" an) und die erwartete Verfügbarkeit in der Freundesgruppe ("VE01") aus, ihr solltet in eurer Arbeit alle Variablen auswählen, die wichtig für eure Auswertung sind. Wenn ihr kein Muster in der Benennung der Variablennamen habt (also EI bzw. K), könnt ihr auch die Ergebnisse des colnames()-Befehls nutzen.

```{r}
colnames(data_roh)
```

::: {.panel-tabset}

### Möglichkeit 1

Wir können einerseits die Spalten direkt mit ihrem Namen ansprechen und auswählen:

```{r}
sel_vars <- c('CASE', 'EI05', 'EI01', 'EI02_01', 'K101_01', 'K101_02', 'K101_03', 'K101_04', 'K101_06', 'K101_08', 'K101_09', 'K101_10', 'K101_05', 'K101_11', 'K201_01', 'K201_02', 'K201_03', 'K201_05', 'K201_06', 'K301_01', 'K301_02', 'K301_03', 'K301_04', 'K301_05', 'K301_06', 'K301_07', 'K301_08', 'K301_09', 'K401_01', 'K401_06', 'K401_02', 'K401_03', 'K401_04', 'K401_05', 'K501_01', 'K501_06', 'K501_03', 'K501_04', 'K501_05', 'VE01')

data_brauchbar <- data_roh[, sel_vars]

```

### Möglichkeit 2

Alternativ können Spalten auch über ihren Index (steht bei dem Output von `colnames()` links) auswählen.

```{r}

sel_vars <- c(1, 7:44, 64)
data_brauchbar <- data_roh[, sel_vars] 

```

:::

Im nächsten Schritt wollen wir die Variablen so umbenennen, dass wir sie im nächsten Schritt einfacher nutzen können. Die notwendige Informationen sind im Codebook enthalten, welches ihr ebenfalls bei SosciSurvey herunterladen könnt. Es macht Sinn, die Namen auch inhaltlich zu benennen, in unserem Beispiel geht es um FOMO (Fear of missing out)

::: {.panel-tabset}

### Möglichkeit 1

Wir können einerseits mit dem `rename(newname = oldname)`-Befehl des *dplyr*-Pakets einzeln Spalten umbennen. 

```{r}

data_brauchbar <- data_brauchbar %>%
  rename(
    id = CASE, zustimmung = EI05, geschlecht = EI01, alter = EI02_01,
    fomo1 = K101_01, fomo2 = K101_02,  fomo3 = K101_03, # ...
    # jede Variable, die geändert werden soll, hier einfügen
  ) 

```

### Möglichkeit 2

Wir können die Spalten auch gleichzeitig umbennen mit dem `colnames()`-Befehl. Dabei machen wir uns zu Nutze, dass die Spaltennamen für FOMO `fomo1`, `fomo2`, `fomo3`, ... bennant werden sollen und wir dadurch mit `paste0("fomo", seq(1, 35))` die 35 Variablennamen in einem Befehl erstellen können. Die Reihenfolge der neuen Spaltennamen muss der Reihenfolge der alten Spaltennamen entsprechen.

```{r}
## Neue Spaltennamen:
colnames(data_brauchbar) <- c(
  "id", "zustimmung", "geschlecht", "alter", 
  paste0("fomo", seq(1, 35)), "verfuegbarkeitserwartung"
  )
```

:::

Nun interessiert es uns, ob es fehlende Werte gibt. Dies kann man mit dem `anyNA()`-Befehl erfragen. Allerdings gibt es hier eine Schwierigkeiten, da SosciSurvey fehlende Werte nicht als NA sondern als -1 bzw. -9 speichert. Aus diesem Grund müssen wir festlegen, dass -1 und -9 als NAs angesehen werden.

```{r}
## Abfrage, ob NAs vorhanden sind:
anyNA(data_brauchbar) # FALSE 

## Abfrage, ob -1 oder -9 vorhanden ist:
any(data_brauchbar == -9) # TRUE
any(data_brauchbar == -1) # TRUE

## Da diese fehlenden Werte vorhanden sind, müssen diese als NAs gelabelt werden:
data_brauchbar[data_brauchbar == -9] <- NA
data_brauchbar[data_brauchbar == -1] <- NA

## Abfrage, ob es nun NAs gibt:
anyNA(data_brauchbar) # TRUE -> das Umlabeln hat also funktioniert 

## Wie viele Daten fehlen:
sum(is.na(data_brauchbar)) # 95 fehlende Angaben
```

In diesem Fall sind 95 fehlende Werte vorhanden. Um die fehlenden Werte genauer zu explorieren, sollte am Rande das naniar-Package erwähnt werden, da es einige nützliche Funktionen diesbezüglich enthält. Wir können zum Beispiel über die Cases (Proband:innen) hinweg die prozentuale Häufigkeit an Missings berechnen.

```{r}
#| output: false

na_count_per_person <- miss_case_summary(data_brauchbar) %>% 
filter(pct_miss > 0) # nur Personen die NAs haben 

print(na_count_per_person)

```


```{r}
#| echo: false
kbl(na_count_per_person, caption = "Anzahl an NAs pro Person")
```

Hier sehen wir nun, dass 2 Proband:innen 35 Items nicht beantwortet haben und 17 Personen mind. 1 NA haben. Die 19 Personen sollen aufgrund der Einfachheit mit `na.omit()` ausgeschlossen werden.

::: {.callout-warning title="Disclaimer zu fehlenden Werten"}
Es sollte zumindest am Rande erwähnt werden, dass die Funktion `na.omit()` sehr mächtig ist und nur mit Vorsicht verwendet werden sollte. Ohne weitere Überlegungen NAs auszuschließen, deren Fehlen möglicherweise nicht zufällig ist, sondern durch andere (nicht)-erhobene Variablen bedingt sind, kann zu Verzerrungen führen.

Für dieses Seminar ist es aber in Ordnung Personen mit fehlenden Werten auszuschließen. Falls ihr euch mehr mit dem Thema NAs auseinandersetzen wollt, hier ein spannender [Blogpost](https://www.iriseekhout.com/post/2022-06-28-missingdatamechanisms/).
:::

```{r}
data_ohneNA <- na.omit(data_brauchbar) # NAs auschließen
```

# Datenaufbereitung

In diesem Abschnitt wird der Datensatz Schritt für Schritt für unsere Analysen vorbereitet. Zuerst wird die Variable Geschlecht (`geschlecht`), die standardmäßig von SosciSurvey aus Zahlen 1 bis 3 beinhaltet, in eine verständlichere Form umgewandelt: Die Zahlen stehen jetzt für "m" (männlich), "w" (weiblich) und "d" (divers). Die Reihenfolge in der die Geschlechter durchnummeriert sind, hängt von eurer Erhebung ab. Ihr könnt diese im Codebook nachschauen.

Die Variable "Erwartung der Verfuegbarkeit" (`verfuegbarkeitserwartung`) beinhaltet inwieweit die eigene Freundesgruppe erwartet, dass man schnell antwortet und für Ihre Anliegen und Probleme verfügbar ist. Diese Variable muss ebenfalls als analog zum Geschlecht als Faktor umkodiert werden. 

```{r}
# Geschlecht:
table(data_ohneNA$geschlecht)

# Umwandlung in Faktor
data_ohneNA$geschlecht <- factor(
  x = data_ohneNA$geschlecht, # Variable auswählen 
  levels = 1:3, # 3 Geschlechter erhoben
  labels = c("m", "w", "d") # Reihenfolge wie auch erhoben wurde
  ) 

table(data_ohneNA$geschlecht)

# Verfuegbarkeitserwartung:
table(data_ohneNA$verfuegbarkeitserwartung)

# Umwandlung in Faktor
data_ohneNA$verfuegbarkeitserwartung <- factor(
  x = data_ohneNA$verfuegbarkeitserwartung,
  levels = c("niedrig", "mittel", "hoch"),
  labels = c("niedrig", "mittel", "hoch")
  )

table(data_ohneNA$verfuegbarkeitserwartung)

```

Bevor wir einen summierten FOMO-Wert berechnen können, müssen wir im Codebook schauen, ob es invertierte Items gibt, d.h. Fragen bei denen hohe Werte (entgegen des inhaltlichen Zusammenhangs) für weniger FOMO spricht. Dies ist für die Items 10, 24, 29, 30, 32 der Fall. Wir können diese Items mit dem `rec(..., rec = "rev")` Befehl des _sjmisc_-Paket sehr einfach invertieren. 

```{r}
# Invertierte Items umkodieren (1 <-> 4, 2 <-> 3 entspricht: 5 - Wert)

data_ohneNA$fomo10_inv <- rec(data_ohneNA$fomo10, rec = "rev")
data_ohneNA$fomo24_inv <- rec(data_ohneNA$fomo24, rec = "rev")
data_ohneNA$fomo29_inv <- rec(data_ohneNA$fomo29, rec = "rev")
data_ohneNA$fomo30_inv <- rec(data_ohneNA$fomo30, rec = "rev")
data_ohneNA$fomo32_inv <- rec(data_ohneNA$fomo32, rec = "rev")

```

Danach können wir einen Gesamtmittelwert "FOMO" für jede Person berechnen, wofür wir den `rowMeans()`-Befehl nutzen.

```{r}

# Liste der Items (inkl. invertierter Items)
fomo_items <- c(
  paste0("fomo", 1:9),
  "fomo10_inv",
  paste0("fomo", 11:23),
  "fomo24_inv",
  paste0("fomo", 25:28),
  "fomo29_inv",
  "fomo30_inv",
  "fomo31",
  "fomo32_inv",
  paste0("fomo", 33:35)
)

# Mittelwert berechnen
data_ohneNA$fomo <- rowMeans(data_ohneNA[, fomo_items])
head(data_ohneNA$fomo)


```

# Exportieren des Datensatzes

Abschließend exportieren wir unseren aufbereiteten Datensatz, damit wir im nächsten Skript weiter damit arbeiten können und tatsächliche deskriptive und inferenzstatistische Analysen durchführen können. Wählt hier einen Ort auf euerem PC und Dateinamen aus, sodass ihr die Datei wiederfindet.

```{r}

write_csv(data_ohneNA, "data/proc/daten_fomo_processed.csv")

```


# Verwendete Pakete

```{r}
sessioninfo::session_info(pkgs = "attached")

```
